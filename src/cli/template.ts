
/**
 * Convert file path to PascalCase class name with nested paths
 * Examples:
 *   users.ts → UsersApi
 *   user-profile.ts → UserProfileApi
 *   users/worker.ts → UsersWorkerApi
 *   employee/worker-profile.ts → EmployeeWorkerProfileApi
 */
function toPascalCase(filePath: string): string {
	// Remove .ts extension
	const withoutExt = filePath.replace(/\.ts$/, "");

	// Split by directory separator and dashes
	const className = withoutExt
		.split("/")
		.flatMap(part => part.split("-"))
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
		.join("");

	return `${className}Api`;
}

/**
 * Get route path from file path
 * Examples:
 *   users.ts → /users
 *   todo-items.ts → /todo-items
 */
export function getRoutePath(filePath: string): string {
	return `/${filePath.replace(/\.ts$/, "")}`;
}

/**
 * Extract resource name from full relative path including nested directories
 * Examples:
 *   todos.ts → todo
 *   users.ts → user
 *   todo-items.ts → todoItem
 *   employee/worker.ts → employeeWorker
 *   employee/worker-profile.ts → employeeWorkerProfile
 */
function getResourceName(relativePath: string): string {
	// Remove .ts extension
	const withoutExt = relativePath.replace(/\.ts$/, "");
	
	// Split by directory separator and dashes, convert to camelCase
	const words = withoutExt
		.split("/")
		.flatMap(part => part.split("-"));
	
	const camelCase = words
		.map((word, index) => {
			if (index === 0) {
				return word.toLowerCase();
			}
			return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
		})
		.join("");
	
	// Remove trailing 's' for singular form (simple pluralization)
	// users → user, todos → todo, posts → post
	if (camelCase.endsWith("s") && camelCase.length > 1) {
		return camelCase.slice(0, -1);
	}
	
	return camelCase;
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
	return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate API class template for new file
 */
export function generateFileTemplate(
	relativePath: string,
): string {
	// Use full relative path for class name generation
	const className = toPascalCase(relativePath);
	const routePath = getRoutePath(relativePath);
	// Use full relative path for resource name to include nested paths
	const resourceName = getResourceName(relativePath);
	const ResourceName = capitalize(resourceName);

	// Use restify alias for imports (configured in vite.config.ts)
	const importPath = "ts-restify";

	// Always include full CRUD operations
	const imports =
		"Body, Collection, DELETE, GET, Logger, Path, POST, PUT, Restify";

	const template = `import { ${imports} } from "${importPath}";

/**
 * API endpoint for ${routePath}
 * Auto-generated by restify-gen
 */
@Collection("${routePath}")
export class ${className} extends Restify {
\t@GET("")
\t@Logger()
\tasync get${ResourceName}s() {
\t\t// GET ${routePath} - Get all ${resourceName}s
\t\treturn {
\t\t\tdata: [],
\t\t};
\t}

\t@GET("/:id")
\t@Logger()
\tasync get${ResourceName}ById(@Path("id") id: string) {
\t\t// GET ${routePath}/:id - Get ${resourceName} by id
\t\treturn {
\t\t\tdata: { id },
\t\t};
\t}

\t@POST("")
\t@Logger()
\tasync create${ResourceName}(@Body() body: unknown) {
\t\t// POST ${routePath} - Create new ${resourceName}
\t\treturn {
\t\t\tdata: { id: "generated-id", ...body as object },
\t\t};
\t}

\t@PUT("/:id")
\t@Logger()
\tasync update${ResourceName}(@Path("id") id: string, @Body() body: unknown) {
\t\t// PUT ${routePath}/:id - Update ${resourceName}
\t\treturn {
\t\t\tdata: { id, ...body as object },
\t\t};
\t}

\t@DELETE("/:id")
\t@Logger()
\tasync delete${ResourceName}(@Path("id") id: string) {
\t\t// DELETE ${routePath}/:id - Delete ${resourceName}
\t\treturn {
\t\t\tdata: { success: true, id },
\t\t};
\t}
}
`;

	return template;
}
