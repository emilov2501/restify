import { readdir, stat, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import { consola } from "consola";

interface RouteInfo {
	path: string;
	filePath: string;
	params: string[];
}

/**
 * Convert file path to route path
 * Examples:
 *   users.ts â†’ /users
 *   posts.ts â†’ /posts
 *   todo-items.ts â†’ /todo-items
 */
function filePathToRoute(filePath: string): RouteInfo {
	// Remove .ts extension
	const withoutExt = filePath.replace(/\.ts$/, "");

	// Simple path conversion - no dynamic params
	const routePath = `/${withoutExt}`;

	return {
		path: routePath,
		filePath,
		params: [], // No params in simplified version
	};
}

/**
 * Recursively scan directory for .ts files
 */
async function scanDirectory(
	dir: string,
	baseDir: string,
): Promise<RouteInfo[]> {
	const routes: RouteInfo[] = [];

	try {
		const entries = await readdir(dir);

		for (const entry of entries) {
			const fullPath = join(dir, entry);
			const stats = await stat(fullPath);

			if (stats.isDirectory()) {
				// Recursively scan subdirectories
				const subRoutes = await scanDirectory(fullPath, baseDir);
				routes.push(...subRoutes);
			} else if (
				entry.endsWith(".ts") &&
				!entry.endsWith(".gen.ts") &&
				!entry.includes("$")
			) {
				// Convert file path to route
				const relativePath = relative(baseDir, fullPath);
				const routeInfo = filePathToRoute(relativePath);
				routes.push(routeInfo);
			}
		}
	} catch (error) {
		if ((error as { code?: string }).code !== "ENOENT") {
			throw error;
		}
		consola.warn(`Directory ${dir} does not exist`);
	}

	return routes;
}

/**
 * Generate TypeScript code for routes
 */
function generateRoutesCode(routes: RouteInfo[]): string {
	const imports = routes
		.map(
			(route, index) =>
				`import * as Route${index} from './api/${route.filePath}';`,
		)
		.join("\n");
	const routeEntries = routes
		.map(
			(route, index) =>
				`  '${route.path}': { module: Route${index}, params: ${JSON.stringify(route.params)} }`,
		)
		.join(",\n");

	// Generate type for route paths
	const routePaths = routes.map((route) => `  | '${route.path}'`).join("\n");

	// Generate type for route params
	const routeParamsTypes = routes
		.filter((route) => route.params.length > 0)
		.map((route) => {
			const paramsType = `{ ${route.params.map((p) => `${p}: string`).join(", ")} }`;
			return `  '${route.path}': ${paramsType};`;
		})
		.join("\n");

	const code = `/**
 * ðŸš€ Auto-generated by restify-gen
 * Do not edit manually
 */

import type { AxiosInstance } from 'axios';
${imports}

export const apiRoutes = {
${routeEntries}
} as const;

export type ApiRoutes = typeof apiRoutes;

export type RoutePath =
${routePaths || "  never"};

export type RouteParams = {
${routeParamsTypes || "  // No routes with params"}
};

export type RouteParamsFor<T extends RoutePath> = T extends keyof RouteParams
  ? RouteParams[T]
  : Record<string, never>;

/**
 * Initialize all API clients with flat structure
 * @param axios - Axios instance for HTTP requests
 * @returns Object with all methods from all APIs
 */
export function initApis(axios: AxiosInstance): ApiClient {
  // Initialize all API instances
${routes.map((route) => {
	const apiName = route.path.split("/").filter(Boolean).pop();
	const className = route.filePath
		.replace(/\.ts$/, "")
		.split("-")
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join("") + "Api";
	return `  const ${apiName}Api = new Route${routes.indexOf(route)}.${className}(axios);`;
}).join("\n")}

  const instances = [${routes.map((route) => {
	const apiName = route.path.split("/").filter(Boolean).pop();
	return `${apiName}Api`;
}).join(", ")}];

  // Merge all methods from all instances
  const merged: Partial<ApiClient> = {};
  for (const instance of instances) {
    const proto = Object.getPrototypeOf(instance);
    const methodNames = Object.getOwnPropertyNames(proto).filter(
      (name) => name !== 'constructor' && typeof instance[name as keyof typeof instance] === 'function'
    );
    for (const method of methodNames) {
      (merged as Record<string, unknown>)[method] = (instance[method as keyof typeof instance] as Function).bind(instance);
    }
  }

  return merged as ApiClient;
}

export type ApiClient = ${routes.map((route) => {
	const className = route.filePath
		.replace(/\.ts$/, "")
		.split("-")
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join("") + "Api";
	return `Route${routes.indexOf(route)}.${className}`;
}).join(" & ")};
`;

	return code;
}

/**
 * Main generator function
 */
export async function generateRoutes(
	apiDir: string,
	outputFile: string,
): Promise<void> {
	consola.info(`ðŸ“‚ Scanning ${apiDir}...`);

	const routes = await scanDirectory(apiDir, apiDir);

	consola.info(`ðŸ“‹ Found ${routes.length} route(s)`);

	for (const route of routes) {
		consola.info(`  ${route.path} â†’ ${route.filePath}`);
	}

	const code = generateRoutesCode(routes);

	await writeFile(outputFile, code, "utf-8");

	consola.success(`âœ“ Generated ${outputFile}`);
}
