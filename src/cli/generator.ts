import { readdir, stat, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import { consola } from "consola";

interface RouteInfo {
	path: string;
	filePath: string;
	params: string[];
}

/**
 * Convert kebab-case to camelCase
 * Examples:
 *   employee-worker â†’ employeeWorker
 *   todo-items â†’ todoItems
 */
function kebabToCamelCase(str: string): string {
	return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Convert file path to route path
 * Examples:
 *   users.ts â†’ /users
 *   posts.ts â†’ /posts
 *   todo-items.ts â†’ /todo-items
 *   employee-worker.ts â†’ /employeeWorker
 */
function filePathToRoute(filePath: string): RouteInfo {
	// Remove .ts extension
	const withoutExt = filePath.replace(/\.ts$/, "");

	// Convert kebab-case to camelCase for route path
	const camelCasePath = kebabToCamelCase(withoutExt);
	const routePath = `/${camelCasePath}`;

	return {
		path: routePath,
		filePath,
		params: [], // No params in simplified version
	};
}

/**
 * Recursively scan directory for .ts files
 */
async function scanDirectory(
	dir: string,
	baseDir: string,
): Promise<RouteInfo[]> {
	const routes: RouteInfo[] = [];

	try {
		const entries = await readdir(dir);

		for (const entry of entries) {
			const fullPath = join(dir, entry);
			const stats = await stat(fullPath);

			if (stats.isDirectory()) {
				// Recursively scan subdirectories
				const subRoutes = await scanDirectory(fullPath, baseDir);
				routes.push(...subRoutes);
			} else if (
				entry.endsWith(".ts") &&
				!entry.endsWith(".gen.ts") &&
				!entry.includes("$")
			) {
				// Convert file path to route
				const relativePath = relative(baseDir, fullPath);
				const routeInfo = filePathToRoute(relativePath);
				routes.push(routeInfo);
			}
		}
	} catch (error) {
		if ((error as { code?: string }).code !== "ENOENT") {
			throw error;
		}
		consola.warn(`Directory ${dir} does not exist`);
	}

	return routes;
}

/**
 * Generate TypeScript code for routes
 */
function generateRoutesCode(routes: RouteInfo[], rootFolder: string): string {
	// Extract path after 'src/' (e.g., 'src/api' -> 'api', 'src/examples/mock' -> 'examples/mock')
	const srcIndex = rootFolder.indexOf("src/");
	const folderName =
		srcIndex >= 0
			? rootFolder.substring(srcIndex + 4) // +4 to skip 'src/'
			: rootFolder.split("/").pop() || "api";

	const imports = routes
		.map(
			(route, index) =>
				`import * as Route${index} from './${folderName}/${route.filePath}';`,
		)
		.join("\n");
	const routeEntries = routes
		.map(
			(route, index) =>
				`  '${route.path}': { module: Route${index}, params: ${JSON.stringify(route.params)} }`,
		)
		.join(",\n");

	// Generate type for route paths
	const routePaths = routes.map((route) => `  | '${route.path}'`).join("\n");

	// Generate type for route params
	const routeParamsTypes = routes
		.filter((route) => route.params.length > 0)
		.map((route) => {
			const paramsType = `{ ${route.params.map((p) => `${p}: string`).join(", ")} }`;
			return `  '${route.path}': ${paramsType};`;
		})
		.join("\n");

	const code = `/**
 * ðŸš€ Auto-generated by restify-gen
 * Do not edit manually
 */

import type { AxiosInstance } from 'axios';
${imports}

export const apiRoutes = {
${routeEntries}
} as const;

export type ApiRoutes = typeof apiRoutes;

export type RoutePath =
${routePaths || "  never"};

export type RouteParams = {
${routeParamsTypes || "  // No routes with params"}
};

export type RouteParamsFor<T extends RoutePath> = T extends keyof RouteParams
  ? RouteParams[T]
  : Record<string, never>;

/**
 * Initialize all API clients with flat structure
 * @param axios - Axios instance for HTTP requests
 * @returns Object with all methods from all APIs
 */
export function initApis(axios: AxiosInstance): ApiClient {
  // Initialize all API instances
${routes
	.map((route) => {
		// Generate variable name from full path (lowercase first letter)
		const varName =
			route.filePath
				.replace(/\.ts$/, "")
				.split("/")
				.flatMap((part) => part.split("-"))
				.map((word, index) =>
					index === 0
						? word.charAt(0).toLowerCase() + word.slice(1)
						: word.charAt(0).toUpperCase() + word.slice(1),
				)
				.join("") + "Api";
		// Generate class name from full path (directories + filename)
		const className =
			route.filePath
				.replace(/\.ts$/, "")
				.split("/")
				.flatMap((part) => part.split("-"))
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join("") + "Api";
		return `  const ${varName} = new Route${routes.indexOf(route)}.${className}(axios);`;
	})
	.join("\n")}

  const instances = [${routes
		.map((route) => {
			// Generate variable name from full path (lowercase first letter)
			const varName =
				route.filePath
					.replace(/\.ts$/, "")
					.split("/")
					.flatMap((part) => part.split("-"))
					.map((word, index) =>
						index === 0
							? word.charAt(0).toLowerCase() + word.slice(1)
							: word.charAt(0).toUpperCase() + word.slice(1),
					)
					.join("") + "Api";
			return varName;
		})
		.join(", ")}]${routes.length > 0 ? " as const" : " as never[]"};

  // Merge all methods from all instances
  const merged: Partial<ApiClient> = {};
  for (const instance of instances) {
    const proto = Object.getPrototypeOf(instance);
    const methodNames = Object.getOwnPropertyNames(proto).filter(
      (name) => name !== 'constructor' && typeof instance[name as keyof typeof instance] === 'function'
    );
    for (const method of methodNames) {
      (merged as Record<string, unknown>)[method] = (instance[method as keyof typeof instance] as Function).bind(instance);
    }
  }

  return merged as ApiClient;
}

export type ApiClient = ${
		routes.length > 0
			? routes
					.map((route) => {
						// Generate class name from full path (directories + filename)
						const className =
							route.filePath
								.replace(/\.ts$/, "")
								.split("/")
								.flatMap((part) => part.split("-"))
								.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
								.join("") + "Api";
						return `Route${routes.indexOf(route)}.${className}`;
					})
					.join(" & ")
			: "Record<string, never>"
	};
`;

	return code;
}

/**
 * Main generator function
 */
export async function generateRoutes(
	apiDir: string,
	outputFile: string,
): Promise<void> {
	consola.info(`ðŸ“‚ Scanning ${apiDir}...`);

	const routes = await scanDirectory(apiDir, apiDir);

	consola.info(`ðŸ“‹ Found ${routes.length} route(s)`);

	for (const route of routes) {
		consola.info(`  ${route.path} â†’ ${route.filePath}`);
	}

	const code = generateRoutesCode(routes, apiDir);

	await writeFile(outputFile, code, "utf-8");

	consola.success(`âœ“ Generated ${outputFile}`);
}
